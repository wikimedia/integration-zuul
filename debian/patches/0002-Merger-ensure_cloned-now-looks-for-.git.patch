From: Antoine Musso <hashar@free.fr>
Date: Tue, 23 Sep 2014 15:31:40 +0200
Subject: Merger: ensure_cloned() now looks for '.git'
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 8bit

merger.Repo() would not clone a directory if the target path already
exists, even though it might not have been cloned.  Adjust the test to
look whether '.git' exist (which can be either a directory or a file in
the case of submodules).

I came accross this issue when using Zuul cloner to clone two
repositories, one having the other as a submodule.

Given two repositories:
- mediawiki/extension
- mediawiki (having 'mediawiki/extension' has a submodule to /extension)

We run: `zuul-cloner mediawiki mediawiki/extension`

It first clone the mediawiki repository with a placeholder directory for
the submodule. The directory structure is:

    .
    ├── .git/
    └── mediawiki/
	└── extension/

When cloning mediawiki/extension, ensure_cloned() would skip it since
the directory exists.  Looking for subpath '.git', we trick it in
cloning the repository resulting in:

    .
    ├── .git/
    │   └── modules/
    │       └── extension/
    └── mediawiki/
	└── extension/
	    └── .git   # note: a file, not a directory

My use case is cloning a mediawiki/core branch which has several
extensions registered as submodules that I am not going to initialize.

Change-Id: I4fe67a1db31adc2e23e8baf57528fce76f282986
---
 tests/test_merger_repo.py | 75 +++++++++++++++++++++++++++++++++++++++++++++++
 zuul/merger/merger.py     |  2 +-
 2 files changed, 76 insertions(+), 1 deletion(-)
 create mode 100644 tests/test_merger_repo.py

diff --git a/tests/test_merger_repo.py b/tests/test_merger_repo.py
new file mode 100644
index 0000000..0cc53bd
--- /dev/null
+++ b/tests/test_merger_repo.py
@@ -0,0 +1,75 @@
+#!/usr/bin/env python
+
+# Copyright 2012 Hewlett-Packard Development Company, L.P.
+# Copyright 2014 Wikimedia Foundation Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License"); you may
+# not use this file except in compliance with the License. You may obtain
+# a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+# License for the specific language governing permissions and limitations
+# under the License.
+
+import logging
+import os
+
+import git
+
+from zuul.merger.merger import Repo
+from tests.base import ZuulTestCase
+from tests.base import FIXTURE_DIR
+
+logging.basicConfig(level=logging.DEBUG,
+                    format='%(asctime)s %(name)-32s '
+                    '%(levelname)-8s %(message)s')
+
+class TestMergerRepo(ZuulTestCase):
+
+    log = logging.getLogger("zuul.test.merger.repo")
+    workspace_root = None
+
+    def setUp(self):
+        super(TestMergerRepo, self).setUp()
+        self.workspace_root = os.path.join(self.test_root, 'workspace')
+
+    def test_ensure_cloned(self):
+        parent_path = os.path.join(self.upstream_root, 'org/project1')
+
+        # Forge a repo having a submodule
+        parent_repo = git.Repo(parent_path)
+        parent_repo.git.submodule('add',
+            os.path.join(self.upstream_root, 'org/project2'), 'subdir')
+        parent_repo.index.commit('Adding project2 as a submodule in subdir')
+        self.assertTrue(
+            os.path.isfile(os.path.join(parent_path, 'subdir', '.git')),
+            msg='.git file in submodule should be a file')
+
+        work_repo = Repo(parent_path, self.workspace_root, 'none@example.org', 'User Name')
+        self.assertTrue(
+            os.path.isdir(os.path.join(self.workspace_root, 'subdir')),
+            msg='Cloned repository has a submodule placeholder directory')
+        self.assertFalse(
+            os.path.exists(os.path.join(self.workspace_root, 'subdir', '.git')),
+            msg='Submodule is not initialized')
+
+        sub_repo = Repo(os.path.join(self.upstream_root, 'org/project2'),
+            os.path.join(self.workspace_root, 'subdir'),
+            'none@example.org', 'User Name')
+        self.assertTrue(
+            os.path.exists(os.path.join(self.workspace_root, 'subdir', '.git')),
+            msg='Cloned over the submodule placeholder')
+
+        self.assertEquals(
+            os.path.join(self.upstream_root, 'org/project1'),
+            work_repo.createRepoObject().remotes[0].url,
+            message="Parent clone still point to upstream project1")
+
+        self.assertEquals(
+            os.path.join(self.upstream_root, 'org/project2'),
+            sub_repo.createRepoObject().remotes[0].url,
+            message="Sub repository points to upstream project2")
diff --git a/zuul/merger/merger.py b/zuul/merger/merger.py
index 8774f10..f36b974 100644
--- a/zuul/merger/merger.py
+++ b/zuul/merger/merger.py
@@ -40,7 +40,7 @@ class Repo(object):
             self.log.exception("Unable to initialize repo for %s" % remote)
 
     def _ensure_cloned(self):
-        repo_is_cloned = os.path.exists(self.local_path)
+        repo_is_cloned = os.path.exists(os.path.join(self.local_path, '.git'))
         if self._initialized and repo_is_cloned:
             return
         # If the repo does not exist, clone the repo.
